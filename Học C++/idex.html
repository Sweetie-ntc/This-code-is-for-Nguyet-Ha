<!doctype html>
<html lang="vi">

<head>
  <title>
  This code is for Nguyet Ha
  </title>
  <!-- Required meta tags -->
     <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="icon" type="image/x-icon" href="/images/favicon.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap"
    rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
  <!-- Bootstrap 4 -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/main.css">

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

</head>

<body class="fullscreen-layout">
  <section id="wainiidev-main">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&display=swap"
    rel="stylesheet">
<style>
    body {
        margin: 0;
        background: #000;
        color: #fff;
        font-weight: 100;
        touch-action: none;
        font-family: "Lora", serif;
    }

    #toggle-music {
        position: fixed;
        top: 16px;
        right: 16px;
        background: none;
        border: 2px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        color: #fff;
        padding: 6px;
        transition: transform 0.2s ease;
        z-index: 999999;
    }

    #toggle-music.playing svg {
        animation: spin 3s linear infinite;
    }

    @keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>

<div class="preview-love-page" id="preview-qr-love-page" data-qr-text="Nguyệt Hà xinh gái, Nguyệt Hà dễ thương nek:>, Nguyệt Hà cổ đáng iu"
    data-qr-images ="Hà nger/1.jpg,Hà nger/2.jpg,Hà nger/3.jpg,Hà nger/4.jpg,Hà nger/5.jpg,Hà nger/6.jpg,Hà nger/7.jpg,Hà nger/8.jpg,Hà nger/9.jpg,Hà nger/10.jpg,Hà nger/11.jpg"
     data-qr-color="#ff69b4" data-page-preview>
    <div id="threejs-canvas"></div>
        <audio id="bg-audio" autoplay preload="auto" loop src="https://res.cloudinary.com/de0ghhr8k/video/upload/v1749660484/uploads/musics/yes_i_do.mp3"></audio>

        <button id="toggle-music" aria-label="Toggle Music">
            <svg id="icon-note" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"
                style="display: none;">
                <path d="M12 3v10.55A4 4 0 1 0 14 17V7h4V3h-6z" fill="currentColor"></path>
            </svg>
            <svg id="icon-note-slash" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"
                style="display: block;">
                <path d="M10 3v10.55A4 4 0 1 0 12 15.55V5h4V3h-6z" fill="currentColor"></path>
                <line x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2"></line>
            </svg>
        </button>
        
</div>

<script>
    const previewLovePage = document.getElementById("preview-qr-love-page");
    document.addEventListener("DOMContentLoaded", function () {
    // Lấy phần tử chứa dữ liệu ảnh
    const previewPage = document.getElementById("preview-qr-love-page");
    const imagesData = previewPage.getAttribute("data-qr-images");
    const images = imagesData.split(",").map(img => img.trim());

    // Tạo phần chứa ảnh
    const imgElement = document.createElement("img");
    imgElement.style.Width = "100%";
    imgElement.style.display = "block";
    imgElement.style.margin = "50px auto";
    imgElement.style.borderRadius = "30px";
    previewPage.appendChild(imgElement);

    let index = 0;
    function showNextImage() {
        imgElement.src = images[index];
        index = (index + 1) % images.length;
    }
    showNextImage();
    setInterval(showNextImage, 4000); // đổi ảnh mỗi 3 giây
    
});
const audio = document.getElementById("bg-audio");
    const toggleBtn = document.getElementById("toggle-music");
    const iconNote = document.getElementById("icon-note");
    const iconNoteSlash = document.getElementById("icon-note-slash");

    toggleBtn.addEventListener("click", function () {
        if (audio.paused) {
            audio.play();
            iconNote.style.display = "block";
            iconNoteSlash.style.display = "none";
        } else {
            audio.pause();
            iconNote.style.display = "none";
            iconNoteSlash.style.display = "block";
        }
    });
    if (previewLovePage) {
        previewLovePage.style.display = "block";

        const iconRegex = /^[^\w\s]+$/; // Regex đơn giản để phát hiện icon/emojis

        const qrTexts = previewLovePage.dataset.qrText.split(",");
        const qrImages = previewLovePage.dataset.qrImages.split(',');
        const qrColors = previewLovePage.dataset.qrColor;
        const texts = qrTexts.concat("💖").concat("🌺");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(95, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        camera.rotation.y = 0.5;

        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("threejs-canvas").appendChild(renderer.domElement);

        renderer.domElement.addEventListener("wheel", (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.006;
            camera.position.z = Math.max(3, Math.min(camera.position.z, 50));
        });

        function hexToRgb(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            return [
                (bigint >> 16) & 255, // R
                (bigint >> 8) & 255,  // G
                bigint & 255          // B
            ];
        }

        function createTextTexture(text) {
            const tempCanvas = document.createElement("canvas");
            const ctx = tempCanvas.getContext("2d");
            let size = 96;
            ctx.font = `bold ${size}px Lora`;
            let w = ctx.measureText(text).width;
            if (w + 200 > 1200) {
                size = Math.floor((size * 1000) / w);
                ctx.font = `bold ${size}px Lora`;
                w = ctx.measureText(text).width;
            }
            const fullCanvas = document.createElement("canvas");
            fullCanvas.width = Math.ceil(w + 200);
            fullCanvas.height = 384;
            const ctx2 = fullCanvas.getContext("2d");
            ctx2.font = `bold ${size}px createHeartTexture`;
            ctx2.textAlign = "center";
            ctx2.textBaseline = "middle";

            if (!iconRegex.test(text)) {
                ctx2.shadowColor = qrColors;
                ctx2.shadowBlur = 100;

            } else {
                ctx2.shadowColor = "#ffffff";
                ctx2.shadowBlur = 300;
            }

            ctx2.fillStyle = "rgb(255,255,255)";

            ctx2.fillText(text, fullCanvas.width / 2, fullCanvas.height / 2);
            ctx2.strokeStyle = "#fff";
            ctx2.lineWidth = 2;
            ctx2.strokeText(text, fullCanvas.width / 2, fullCanvas.height / 2);
            return {
                texture: new THREE.CanvasTexture(fullCanvas),
                aspect: fullCanvas.width / fullCanvas.height
            };
        }

        function createHeartTexture(img) {
            const canvas = document.createElement("canvas");
            canvas.width = 500;
            canvas.height = 500;
            const ctx = canvas.getContext("2d");
            ctx.clearRect(10, 10, 500, 500);
            ctx.shadowColor = "#ff69b4";
            ctx.shadowBlur = 30;
            ctx.drawImage(img, 64, 64, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        const starMeshes = [], textMeshes = [], heartMeshes = [], shootingStars = [];

        function createStars() {
            const geom = new THREE.SphereGeometry(0.07, 6, 6);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = 0; i < 800; i++) {
                const star = new THREE.Mesh(geom, mat);
                star.position.set((Math.random() - 0.5) * 120, Math.random() * 80 - 20, (Math.random() - 0.5) * 120 - 20);
                scene.add(star);
                starMeshes.push(star);
            }
        }

        function createFallingTexts() {
            textMeshes.forEach(t => scene.remove(t));
            textMeshes.length = 0;
            for (let i = 0; i < 160; i++) {
                const text = texts[Math.floor(Math.random() * texts.length)];
                const { texture, aspect } = createTextTexture(text);
                const geo = new THREE.PlaneGeometry(3 * aspect, 3);
                const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthWrite: false });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random() - 0.5) * 100, Math.random() * 32 - 12, (Math.random() - 0.5) * 40);
                mesh.userData.phase = Math.random() * Math.PI * 2;
                mesh.userData.isIcon = iconRegex.test(text);
                scene.add(mesh);
                textMeshes.push(mesh);
            }
        }

        function createFallingHearts(textureImageUrls) {
            // Xóa trái tim cũ khỏi scene
            heartMeshes.forEach((heartMesh) => scene.remove(heartMesh));
            heartMeshes.length = 0;

            const loader = new THREE.TextureLoader();
            const loadedTextures = [];
            let loadedCount = 0;

            // Tải tất cả ảnh
            textureImageUrls.forEach((url, index) => {
                loader.load(url, (texture) => {
                    loadedTextures[index] = texture;
                    loadedCount++;

                    // Khi tất cả ảnh đã được load
                    if (loadedCount === textureImageUrls.length) {
                        // Tạo trái tim từ các texture đã load
                        for (let i = 0; i < 15; i++) {
                            const randomTexture = loadedTextures[Math.floor(Math.random() * loadedTextures.length)];

                            const plane = new THREE.PlaneGeometry(1, 1);
                            const material = new THREE.MeshBasicMaterial({
                                map: randomTexture,
                                transparent: true,
                                depthWrite: false,
                                depthTest: true,
                            });

                            const heartMesh = new THREE.Mesh(plane, material);
                            heartMesh.position.x = (Math.random() - 0.5) * 30;
                            heartMesh.position.y = Math.random() * 32 - 12;
                            heartMesh.position.z = (Math.random() - 0.5) * 20;

                            const scale = 1 + Math.random() * 1.5;
                            heartMesh.scale.set(scale, scale, 1);

                            heartMesh.userData.velocityY = 0.03 + Math.random() * 0.02;
                            heartMesh.userData.velocityX = (Math.random() - 0.5) * 0.02;

                            scene.add(heartMesh);
                            heartMeshes.push(heartMesh);
                        }
                    }
                });
            });
        }


        function spawnShootingStar() {
            const sphere = new THREE.SphereGeometry(0.15, 8, 8);
            const mesh = new THREE.MeshBasicMaterial({
                color: 16777215,
                transparent: true,
            });
            const shootingStarMesh = new THREE.Mesh(sphere, mesh);
            shootingStarMesh.position.x = (Math.random() - 0.5) * 100;
            shootingStarMesh.position.y = Math.random() * 80 - 20;
            shootingStarMesh.position.z = -40 - Math.random() * 40;
            shootingStarMesh.userData = {
                vx: 0.4 + Math.random() * 0.3,
                vy: -0.2 - Math.random() * 0.2,
                vz: 0.7 + Math.random() * 0.5,
                tail: [],
            };
            scene.add(shootingStarMesh);
            shootingStars.push(shootingStarMesh);
        }
        let isDragging = false;
        let lastX = 0;
        let isTouching = false;
        let lastTouchX = 0;
        let targetRotationY = 0.5;
        renderer.domElement.addEventListener("mousedown", (e) => {
            isDragging = true;
            lastX = e.clientX;
        });
        window.addEventListener("mouseup", () => {
            isDragging = false;
        });
        window.addEventListener("mousemove", (e) => {
            if (isDragging) {
                const _0x4ad287 = e.clientX - lastX;
                lastX = e.clientX;
                targetRotationY += _0x4ad287 * 0.0015;
            }
        });
        renderer.domElement.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                isTouching = true;
                lastTouchX = e.touches[0].clientX;
            }
        });
        window.addEventListener("touchend", () => {
            isTouching = false;
        });
        window.addEventListener("touchmove", (e) => {
            if (isTouching && e.touches.length === 1) {
                const clientX = e.touches[0].clientX;
                const rotationY = clientX - lastTouchX;
                lastTouchX = clientX;
                targetRotationY += rotationY * 0.0015;
            }
        });
        function animate() {
            requestAnimationFrame(animate);
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.08;
            const now = Date.now();
            console.log('textMeshes', textMeshes);

            textMeshes.forEach((fallingText) => {
                fallingText.position.y -= 0.025 + Math.random() * 0.005;
                if (fallingText.position.y < -12) {
                    fallingText.position.y = Math.random() * 20 + 10;
                    fallingText.position.x = (Math.random() - 0.5) * 30;
                    fallingText.position.z = (Math.random() - 0.5) * 40;
                }
                if (fallingText.position.x > 16) {
                    fallingText.position.x = -16;
                }
                if (fallingText.position.x < -16) {
                    fallingText.position.x = 16;
                }

                if (fallingText.userData.isIcon) {
                    return; // Không thay đổi màu sắc cho icon/emojis
                }

                const ratio = (Math.sin(now * 0.0005 + fallingText.userData.phase) + 1) / 2;
                const hexColor = hexToRgb(qrColors);
                const colors = [
                    Math.round(
                        [255, 255, 255][0] + (hexColor[0] - [255, 255, 255][0]) * ratio
                    ),
                    Math.round(
                        [255, 255, 255][1] + (hexColor[1] - [255, 255, 255][1]) * ratio
                    ),
                    Math.round(
                        [255, 255, 255][2] + (hexColor[2] - [255, 255, 255][2]) * ratio
                    ),
                ];
                const interpolatedHexColor =
                    (colors[0] << 16) | (colors[1] << 8) | colors[2];
                fallingText.material.color.setHex(interpolatedHexColor);
            });

            heartMeshes.forEach((fallingHeart) => {
                // Cập nhật vị trí theo velocity
                fallingHeart.position.y -= fallingHeart.userData.velocityY;
                fallingHeart.position.x += fallingHeart.userData.velocityX;

                // Nếu rơi xuống quá thấp, reset lại vị trí và velocity mới
                if (fallingHeart.position.y < -12) {
                    fallingHeart.position.y = Math.random() * 20 + 10;
                    fallingHeart.position.x = (Math.random() - 0.5) * 30;
                    fallingHeart.position.z = (Math.random() - 0.5) * 20;

                    fallingHeart.userData.velocityY = 0.03 + Math.random() * 0.02;
                    fallingHeart.userData.velocityX = (Math.random() - 0.5) * 0.02;
                }

                // Giới hạn chuyển động trái/phải trong khung
                if (fallingHeart.position.x > 16) {
                    fallingHeart.position.x = -16;
                }
                if (fallingHeart.position.x < -16) {
                    fallingHeart.position.x = 16;
                }
            });

            shootingStars.forEach((star, index) => {
                if (star.userData.tail.length > 20) {
                    star.userData.tail.shift();
                }
                star.userData.tail.push({
                    x: star.position.x,
                    y: star.position.y,
                    z: star.position.z,
                });
                star.position.x += star.userData.vx;
                star.position.y += star.userData.vy;
                star.position.z += star.userData.vz;
                for (let i = 0; i < star.userData.tail.length - 1; i++) {
                    const curItem = star.userData.tail[i];
                    const nextItem = star.userData.tail[i + 1];
                    const buffer = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(curItem.x, curItem.y, curItem.z),
                        new THREE.Vector3(nextItem.x, nextItem.y, nextItem.z),
                    ]);
                    const lineBasic = new THREE.LineBasicMaterial({
                        color: 16777215,
                        transparent: true,
                        opacity: 0.15 + 0.25 * (i / star.userData.tail.length),
                    });
                    const line = new THREE.Line(buffer, lineBasic);
                    scene.add(line);
                    setTimeout(() => scene.remove(line), 40);
                }
                star.material.opacity = 0.8;
                if (star.position.z > 0 || star.position.y < -40) {
                    scene.remove(star);
                    shootingStars.splice(index, 1);
                }
            });
            if (Math.random() < 0.012) {
                spawnShootingStar();
            }
            renderer.render(scene, camera);
        }

        window.addEventListener("resize", () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });

        createStars();
        createFallingTexts();
        createFallingHearts(qrImages);
        animate();
    }

</script>
  </section>
  <!-- Optional JavaScript -->
  <!-- jQuery first, then Popper.js, then Bootstrap JS -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"
    integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>
  <script type="text/javascript" src="//cdn.jsdelivr.net/gh/kenwheeler/slick@1.8.1/slick/slick.min.js"></script>
  <script type="module" src="/js/app.js"></script>

</body>

</html>